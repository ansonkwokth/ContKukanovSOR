# Cont & Kukanov Strategy Backtesting & Optimization Framework

This repository provides a modular framework for evaluating the Cont & Kukanov (C&K) strategy for Smart Order Routing (SOR), as described in"[Optimal Order Placement in Limit Order Markets](https://arxiv.org/pdf/1210.1625])", using historical Level 1 (L1) limit order book data. It also includes a grid search module for hyperparameter optimization.

## Short Conculsion 

To run the backtest with optimization, generate a plot, and save the results to a file, you can use the following command:
```
python3 backtest.py -f data/l1_day.csv --optimize config/optimize_config.yaml --plot_path result.png | tee result.json
```
Breakdown of the command:
- `python3 backtest.py`: Executes the Python backtest script.
- `-f data/l1_day.csv`: Specifies the input data file (data/l1_day.csv) for the backtest.
- `--optimize config/optimize_config.yaml`: Provides the optimization configuration file (config/optimize_config.yaml) that defines the optimization parameters.
- `--plot_path result.png`: Generates and saves a plot of the results to the file result.png.
- `| tee result.json`: Captures the standard output (stdout) and displays it in the terminal while simultaneously saving it to the result.json file. This allows you to track the progress in real-time and keep a record of the output.

Output:
- `result.png`: The plot generated by the backtest showing the results. (where the x label can also be shown in time axis, see Additional Features section example)
- `result.json`: A JSON file containing the output from the backtest, including the performance summary and optimization results.

![alt text](https://github.com/ansonkwokth/ContKukanovSOR/blob/master/result.png?raw=true)

## Improving Fill Realism

### Problem
The current backtest assumes immediate fills at posted ask prices up to displayed size, ignoring latency between observing the book and executing the order. In reality, the order book may change before the order arrives, leading to slippage.

### Proposed Improvement: Queue Flow Simulation
Introduce randomness into the model by simulating queue outflow $\xi \sim F$, where $F$ is a distributon, captures the volume during latency.

### Method
Replace deterministic fills with stochastic simulation using Monte Carlo.
Run multiple backtests over different random seed of $\xi$ to obtain a distribution of `total_cost`.
Optimize parameters `(θ, λu, λo)` with respect to the obtained distribution of `total_cost` or risk measures.

### Bonus: Learn $F$ from Real Data
To reduce model bias, estimate $F$ directly from historical order book flows during latency windows.




# Detailed Discussion
## Approach

The core idea is to compute optimal order allocations under varying market conditions—specifically different ask prices and volumes—based on historical L1 data. The framework supports:
- Easy addition of new or baseline strategies under the `strategies/` directory
- Modular backtesting (`backtest.py`) that outputs a summary of performance and corresponding visual plots. The backtest loop is designed to support easy integration of multiple baseline strategies for side-by-side comparison.
- Configurable optimizer settings via `optimize_config`, allowing you to define the optimizer parameters easily.

You can run a basic backtest using: `python3 backtest.py -f data/l1_day.csv` with the default paramter without optimization. Moreover, the script also accepts additional flexible parameters for more customized runs. To view all available options, use: `python3 backtest.py -h` 

```
usage: backtest.py [-h] -f FILE [--lambda_over LAMBDA_OVER] [--lambda_under LAMBDA_UNDER] [--theta_queue THETA_QUEUE] [--order_size ORDER_SIZE]
                   [--fee FEE] [--rebate REBATE] [--optimize_config OPTIMIZE_CONFIG] [--early_stop EARLY_STOP] [--plot_path PLOT_PATH]
```

Note: In this setup, the fee and rebate are the same across all venues. An improvement can be made by creating a configuration file for venue-specific information, which could then be imported into the backtest script for more granular control. Then the path to configuration file can be the new argument. 

## Code Structure

```
├── backtest.py                 # Main backtesting loop and evaluation logic
├── data/                       # Real and/or synthetic L1 market data
├── logs/                       # Logs from backtest or optimization runs
├── strategies/
│   ├── SOR_strategy.py         # Cont & Kukanov SOR strategy implementation
│   ├── allocator.py            # C&K order allocation logic
│   ├── naive_strategy.py       # Naïve “take the best ask” strategy
│   ├── twap_strategy.py        # Time-Weighted Average Price strategy
│   └── vwap_strategy.py        # Volume-Weighted Average Price strategy
└── utils/
    ├── data.py                 # Data loading and preprocessing
    ├── gen_fake_data.py        # Generate synthetic L1 data for testing
    ├── helpers.py              # Helper functions
    ├── logger.py               # Logging utilities
    └── venue.py                # Venue data structure
```

### Discussion on Allocator
The `allocator.py` module implements the core allocation logic from C&K, designed to be minimal, testable, and extensible. It includes simple test cases for sanity checking, by running `python3 strategies/allocator.py`:

```
order_size = 5000

venues = [Venue(ask=222.74, ask_size=9220, fee=0.01, rebate=0.002)]
# Best Split: [5000]

venues = [Venue(ask=10.1, ask_size=1000, fee=0.01, rebate=0.002)]
# Best Split: [0]
```
These examples test:
- Case 1: `ask_size > order_size` → full fill possible
- Case 2: `ask_size < order_size` → cannot fill

Multi-venue scenarios are also supported:
```
venues = [
          Venue(ask=222.83, ask_size=5000, fee=0, rebate=0.),
          Venue(ask=222.81, ask_size=400, fee=0., rebate=0,)
]
# Best Split: [4600, 400]

venues = [
          Venue(ask=222.83, ask_size=5000, fee=0, rebate=1),
          Venue(ask=222.81, ask_size=400, fee=100, rebate=0)
]
# Best Split: [5000, 0]
```
These examples test (when `sum(ask_sizes) > order_size`):
- Case 1: Fill lower ask venue first until capacity is reached
- Case 2: Avoid the venue with high fees, even if the ask price is lower


### Discussion on Data Loading and Cleaning
Data loading and preprocessing are handled by the `utils/data.py` script, which returns a list of L1 order book snapshots used in the backtest.

Since the sample dataset contains only a single `publisher_id`, it does not reflect a multi-venue environment. To simulate multiple venues and test strategy behavior in such settings, you can use the `utils/gen_fake_data.py` script. This script duplicates each message in `ts_event` and modifies the `publisher_id` of the duplicate to `-1`, effectively creating a synthetic second venue.

You can generate the fake data with:
```
python3 utils/gen_fake_data.py -i data/l1_day.csv -o data/l1_day_fake.csv
```
This will take `data/l1_day.csv` as input and save the generated multi-venue data to `data/l1_day_fake.csv`.

You can then test the backtest framework on the synthetic data using:
```
python3 backtest.py -f data/l1_day_fake.csv
```



## Parameter Ranges

### A data-driven perspective

I would begin by searching for the order of magnitude of the parameters. For instance, I would explore combinations such as `[0, 0.01, 0.1, 1, 10, 100, 1000]`. Once the best result from this search is found, I would then perform a more fine-grained search on a linear scale to further refine the optimal values.

Currently, this combination of order of magnitude and linear scale search is not supported in the existing version of the framework. However, it can be implemented by modularizing the optimization logic. By creating a dedicated optimizer in the optimizer/ directory, you can define the search strategies for both the order of magnitude and linear scale approaches. You can then call the new optimizer using the `.yaml` configuration file.

### A theoretical perspective

As described in the pseudo-code:
```
risk_pen  ← θ * (underfill + overfill)
cost_pen  ← λu * underfill + λo * overfill
tot_cost  ← cash_spent + risk_pen + cost_pen
```
This suggests the following total cost equation:
```
tot_cost  ← cash_spent + θ * (underfill + overfill) + (λu * underfill + λo * overfill)
```
Upon closer examination, the parameter `θ` becomes redundant in this formulation, as it is just a constant added to both `λu` and `λo`. To speed up the optimization, we can skip the `θ` term and redefine the parameters `λu'` and `λo'`:
```
tot_cost  ← cash_spent + (λu' * underfill + λo' * overfill)
```
where `λu' = θ + λu`, `λo' = θ + λo`. This simplification removes the unnecessary `θ` parameter from the optimization process, while still maintaining the same outcome. This makes the optimization process faster and more efficient.


Note also that the order of magnitude of execution order size (`O(exe)`) is from the range: `O(order_size) ~ O(ask_size)`. Consequently, the `O(cash_spent)` term is roughly `O(ask)*O(order_size) ~ O(ask)*O(ask_size)`.

Given the following definitions:
```
underfill ← max(order_size - executed, 0)
overfill  ← max(executed - order_size, 0)
```

It suggests that `O(underfill)` and `O(overfill)` are also on the order of `O(order_size) ~ O(ask_size)`.

To ensure that the penalty terms have a non-negligible contribution to `tot_cost`, I recommend setting the parameters `θ`, `λu`, and `λo` in the order of magnitude `O(0.1*ask) ~ O(ask)`.


## Additional Features

One can also run:
```
python3 backtest.py -f data/l1_day.csv --early_stop True --plot_path result_early_stop.png 
```
to enable early stopping in the backtest—terminating once the C&R strategy fully fills the order.

An example output is shown in `result_early_stop.png`.
![alt text](https://github.com/ansonkwokth/ContKukanovSOR/blob/master/result_early_stop.png?raw=true)
